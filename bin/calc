#!/usr/bin/env perl
use warnings;
use strict;
use Scalar::Util qw(looks_like_number);
use File::Basename qw(dirname);

use lib dirname(__FILE__) . "/../lib";
use My::Calc::Functions qw(:all);

our $format;

use Getopt::Long;
Getopt::Long::GetOptions(
    "f|format=s" => \$format,
) or die(":-(\n");

use Term::ReadLine;
use Text::Wrap;

our $last_result = 0;

sub _ () {
    # prototype required for things like "_ + 5" to work
    return $last_result;
}

if (!scalar @ARGV && -t 0 && -t 1) {
    my $green = `tput setaf 2`;
    my $reset = `tput sgr0`;
    my $has_term_readline_gnu  = eval { require Term::ReadLine::Gnu };
    my $has_term_readline_perl = eval { require Term::ReadLine::Perl };
    my $has_term_readline_zoid = eval { require Term::ReadLine::Zoid };
    my $term_readline_class =
      defined $ENV{TERM_RL} ? $ENV{TERM_RL} :
      $has_term_readline_gnu ? "Term::ReadLine::Gnu" :
      $has_term_readline_zoid ? "Term::ReadLine::Zoid" :
      $has_term_readline_perl ? "Term::ReadLine::Perl" :
      "Term::ReadLine";
    warn("Loading $term_readline_class\n");
    my $term = $term_readline_class->new('calc');
    my $prompt = "${green}calc>${reset} ";
    while (defined($_ = $term->readline($prompt))) {
        evaluate_print();
    }
} else {
    while (<>) {
        evaluate_print();
    }
}

sub evaluate_print {
    if (/^\s*(help|\?)\s*$/i) {
        my @functions = My::Calc::Functions::calc_functions();
        @functions = sort @functions;
        print(wrap('', '', join(', ', @functions)), "\n");
        return;
    }
    my $result = evaluate($_);
    if ($@) {
        warn($@);
        return;
    }
    print("$result\n");
}

sub evaluate {
    my ($expr, $fmt) = @_;
    $fmt = $fmt // $format;
    return $expr if looks_like_number($expr) && !defined $fmt;
    my $result = do {
        no warnings;
        no strict;
        eval($expr);
    };
    if (defined $result) {
        $last_result = $result;
    }
    return $result;
}
